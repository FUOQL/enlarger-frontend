import {n  Rows,n  Text,n  FileInput,n  SegmentedControl,n  Button,n  ProgressBar,n  Alert,n  FormField,n  FileInputItem,n  Title,n  Box,n  ReloadIcon,n  Slider,n  CogIcon,n  ExportIcon,n} from "@canva/app-ui-kit";nimport { useEffect, useMemo, useRef, useState } from "react";nimport type {n  ContentDraft,n  ImageRef,n  ImageElementAtPointn} from "@canva/design";nimport { addElementAtPoint, selection } from "@canva/design";nimport { useMutation } from "@tanstack/react-query";nimport styles from "styles/components.css";nimport type { ImageMimeType } from "@canva/asset";nimport { getTemporaryUrl, upload } from "@canva/asset";nnasync function fileToDataUrl(file: Blob) {n  return new Promise<string>((resolve) => {n    const reader = new FileReader();n    reader.onload = () => {n      resolve(reader.result as string);n    };n    reader.readAsDataURL(file);n  });n}nnasync function readCanvaNativeImageURL(url: string): Promise<File> {n  const res = await fetch(url);n  const formatMatch = url.match(/format:([A-Z]+)/);n  const ext = formatMatch ? formatMatch[1].toLowerCase() : "png";n  return new File([await res.blob()], `selected-image.${ext}`, {n    type: `image/${ext}`,n  });n}nn// Mirror flip functionnasync function flipImage(n  imageUrl: string, n  flipType: 'horizontal' | 'vertical' | 'both',n  position: 'below' | 'above' | 'left' | 'right',n  offset: number,n  opacity: numbern): Promise<string> {n  return new Promise((resolve) => {n    const canvas = document.createElement('canvas');n    const ctx = canvas.getContext('2d')!;n    const img = new Image();n    n    img.onload = () => {n      // Set canvas sizen      let canvasWidth = img.width;n      let canvasHeight = img.height;n      n      // Adjust canvas size based on positionn      if (position === 'below' || position === 'above') {n        canvasHeight = img.height * 2 + offset;n      } else if (position === 'left' || position === 'right') {n        canvasWidth = img.width * 2 + offset;n      }n      n      canvas.width = canvasWidth;n      canvas.height = canvasHeight;n      n      // Clear canvasn      ctx.clearRect(0, 0, canvasWidth, canvasHeight);n      n      // Draw original imagen      let originalX = 0;n      let originalY = 0;n      let flippedX = 0;n      let flippedY = 0;n      n      switch (position) {n        case 'below':n          originalY = 0;n          flippedY = img.height + offset;n          break;n        case 'above':n          originalY = img.height + offset;n          flippedY = 0;n          break;n        case 'left':n          originalX = img.width + offset;n          flippedX = 0;n          break;n        case 'right':n          originalX = 0;n          flippedX = img.width + offset;n          break;n      }n      n      ctx.drawImage(img, originalX, originalY);n      n      // Apply flip effectn      ctx.save();n      ctx.globalAlpha = opacity / 100;n      n      if (flipType === 'horizontal' || flipType === 'both') {n        ctx.scale(-1, 1);n        ctx.translate(-flippedX - img.width, flippedY);n      } else if (flipType === 'vertical' || flipType === 'both') {n        ctx.scale(1, -1);n        ctx.translate(flippedX, -flippedY - img.height);n      }n      n      ctx.drawImage(img, 0, 0);n      ctx.restore();n      n      resolve(canvas.toDataURL('image/png'));n    };n    n    img.src = imageUrl;n  });n}nnfunction downloadImage(dataUrl: string, filename: string) {n  try {n    // Method 1: Create download linkn    const link = document.createElement('a');n    link.href = dataUrl;n    link.download = filename;n    link.style.display = 'none';n    document.body.appendChild(link);n    link.click();n    document.body.removeChild(link);n    n    // Method 2: If Method 1 fails, try opening in new tabn    setTimeout(() => {n      const newWindow = window.open();n      if (newWindow) {n        newWindow.document.write(`n          <html>n            <head><title>Download Image</title></head>n            <body>n              <h2>Right-click on the image below and select "Save image as..."</h2>n              <img src="${dataUrl}" alt="Mirror flip result" style="max-width: 100%; height: auto;" />n            </body>n          </html>n        `);n        newWindow.document.close();n      }n    }, 1000);n    n    return true;n  } catch (error) {n    console.error('Download failed:', error);n    return false;n  }n}nnexport const App = () => {n  const [selectedFile, setSelectedFile] = useState<File | null>(null);n  const [imageUrl, setImageUrl] = useState<string>("");n  const [flipType, setFlipType] = useState<"horizontal" | "vertical" | "both">("horizontal");n  const [position, setPosition] = useState<"below" | "above" | "left" | "right">("below");n  const [offset, setOffset] = useState(20);n  const [opacity, setOpacity] = useState(80);n  const [processing, setProcessing] = useState(false);n  const [flippedImageUrl, setFlippedImageUrl] = useState<string>("");n  const [downloadStatus, setDownloadStatus] = useState<string>("");n  n  const fileInputRef = useRef<HTMLInputElement>(null);n  n  // Mutation for adding/replacing elementsn  const addElementMutation = useMutation({n    mutationFn: async (imageRef: ImageRef) => {n      const draft = await ContentDraft.get();n      await addElementAtPoint(draft, imageRef, { x: 0, y: 0 });n    },n  });n  n  // Register selection change listenern  useEffect(() => {n    const unsubscribe = selection.registerOnChange({n      onChange: async (selection) => {n        const imageElements = selection.elements.filter(n          (element): element is ImageElementAtPoint =>n            element.type === "image"n        );n        n        if (imageElements.length > 0) {n          const imageElement = imageElements[0];n          const url = await getTemporaryUrl(imageElement.ref);n          const file = await readCanvaNativeImageURL(url);n          setSelectedFile(file);n          setImageUrl(url);n        }n      },n    });n    n    return unsubscribe;n  }, []);n  n  const handleFlipImage = async () => {n    if (!imageUrl) return;n    n    setProcessing(true);n    try {n      const flippedUrl = await flipImage(imageUrl, flipType, position, offset, opacity);n      setFlippedImageUrl(flippedUrl);n    } catch (error) {n      console.error("Error flipping image:", error);n    } finally {n      setProcessing(false);n    }n  };n  n  // Auto-regenerate when parameters changen  useEffect(() => {n    if (imageUrl && flippedImageUrl) {n      handleFlipImage();n    }n  }, [flipType, position, offset, opacity]);n  n  const resetData = () => {n    setSelectedFile(null);n    setImageUrl("");n    setFlippedImageUrl("");n    setDownloadStatus("");n    if (fileInputRef.current) {n      fileInputRef.current.value = "";n    }n  };n  n  const handleDownload = () => {n    if (!flippedImageUrl) return;n    n    setDownloadStatus("Downloading...");n    n    const filename = selectedFile n      ? `flipped_${selectedFile.name.replace(/\.[^/.]+$/, "")}.png`n      : `flipped_image_${Date.now()}.png`;n    n    const success = downloadImage(flippedImageUrl, filename);n    n    if (success) {n      setDownloadStatus("Download started! Check your downloads folder.");n      setTimeout(() => setDownloadStatus(""), 3000);n    } else {n      setDownloadStatus("Download failed. Try right-clicking the image and 'Save as...'");n      setTimeout(() => setDownloadStatus(""), 5000);n    }n  };n  n  const flipTypeOptions = useMemo(() => [n    { value: "horizontal" as const, label: "Horizontal" },n    { value: "vertical" as const, label: "Vertical" },n    { value: "both" as const, label: "Both" }n  ], []);n  n  const positionOptions = useMemo(() => [n    { value: "below" as const, label: "Below" },n    { value: "above" as const, label: "Above" },n    { value: "left" as const, label: "Left" },n    { value: "right" as const, label: "Right" }n  ], []);n  n  return (n    <div className={styles.mainContainer}>n      <div className={styles.welcomeSection}>n        <Title>Mirror Flip Tool</Title>n        <Text tone="secondary">Create stunning mirror flip effects on your images</Text>n      </div>n      n      <div className={styles.uploadSection}>n        <FormFieldn          label="Select Image"n          hint="Upload an image to get started"n        >n          <FileInputn            ref={fileInputRef}n            onChange={async (event) => {n              const file = event.target.files?.[0];n              if (file) {n                setSelectedFile(file);n                const dataUrl = await fileToDataUrl(file);n                setImageUrl(dataUrl);n                setFlippedImageUrl("");n              }n            }}n            accept="image/*"n          />n        </FormField>n        n        {selectedFile && (n          <div className={styles.imagePreviewContainer}>n            <imgn              src={imageUrl}n              alt="Selected image"n              className={styles.imagePreview}n            />n            <div className={styles.imageOverlay}>n              <Text tone="secondary">Original Image</Text>n            </div>n          </div>n        )}n      </div>n      n      {imageUrl && (n        <div className={styles.controlsSection}>n          <div className={styles.controlGroup}>n            <div className={styles.controlGroupTitle}>Flip Type</div>n            <SegmentedControln              options={flipTypeOptions}n              value={flipType}n              onChange={setFlipType}n            />n          </div>n          n          <div className={styles.controlGroup}>n            <div className={styles.controlGroupTitle}>Position</div>n            <SegmentedControln              options={positionOptions}n              value={position}n              onChange={setPosition}n            />n          </div>n          n          <div className={styles.controlGroup}>n            <div className={styles.controlGroupTitle}>Offset Distance: {offset}px</div>n            <Slidern              value={offset}n              min={0}n              max={100}n              step={1}n              onChange={(e) => setOffset(e.target.value as number)}n            />n          </div>n          n          <div className={styles.controlGroup}>n            <div className={styles.controlGroupTitle}>Opacity: {opacity}%</div>n            <Slidern              value={opacity}n              min={10}n              max={100}n              step={1}n              onChange={(e) => setOpacity(e.target.value as number)}n            />n          </div>n        </div>n      )}n      n      {flippedImageUrl && (n        <div className={styles.previewContainer}>n          <div className={styles.previewHeader}>n            <Title>Result</Title>n            <div className={styles.actionButtons}>n              <Buttonn                variant="primary"n                onClick={handleDownload}n                disabled={processing}n              >n                Download Imagen              </Button>n              <Buttonn                variant="secondary"n                onClick={resetData}n              >n                Start Overn              </Button>n            </div>n          </div>n          n          <div className={styles.resultImageContainer}>n            <imgn              src={flippedImageUrl}n              alt="Mirror flip result"n              className={styles.resultImage}n            />n            <div className={styles.downloadHint}>n              <Text tone="secondary">Right-click the image and select "Save image as..."</Text>n            </div>n          </div>n          n          {downloadStatus && (n            <Alert tone="info">n              {downloadStatus}n            </Alert>n          )}n        </div>n      )}n      n      {processing && (n        <div className={styles.processingOverlay}>n          <ProgressBar />n          <Text>Processing image...</Text>n        </div>n      )}n    </div>n  );n};